# -*- coding: utf-8 -*-
"""DA Lab Assignment-3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fP2KdUyHhDleaGypDMpRVBa4niFcNcWd

1. Write a program in R/Python for the following:
Consider the following grouped data:
Table 1: Grouped data of marks obtained by students of a class:
30-40 40-50 50-60 60-70 70-80 80-90 90-100
10 15 18 27 35 19 6
Compute the mean using:
i. Direct method
ii. Assumed mean method
iii. Step deviation method
"""

# Direct method

def mean_grouped_data(data):
    sum_of_products = 0
    total_frequency = 0

    for frequency, value in data:
        sum_of_products += value * frequency
        #print(sum_of_products)
        total_frequency += frequency
        #print(total_frequency)

    mean = sum_of_products / total_frequency

    return mean

data = [[10, 35], [15, 45], [18, 55], [27, 65], [35, 75], [19, 85], [6, 95]]

mean = mean_grouped_data(data)

print("The mean of the group data is", mean)

# Assumed mean method

def mean_grouped_data_assumed_mean(data, assumed_mean):
    sum_of_adjustments = 0
    total_frequency = 0

    for  frequency,value in data:
        deviation = value - assumed_mean
        sum_of_adjustments += deviation * frequency
        total_frequency += frequency

    mean = assumed_mean + sum_of_adjustments / total_frequency

    return mean

data = [[10, 35], [15, 45], [18, 55], [27, 65], [35, 75], [19, 85], [6, 95]]
assumed_mean = 50  # You can change this to any assumed mean value

mean_assumed = mean_grouped_data_assumed_mean(data, assumed_mean)

print("The assumed mean of the group data is", assumed_mean)
print("The mean calculated using the Assumed Mean method is", mean_assumed)

# Step deviation method

def mean_grouped_data_step_deviation(data, reference_value):
    sum_of_product_deviations = 0
    total_frequency = 0

    for frequency,value  in data:
        deviation = value - reference_value
        sum_of_product_deviations += deviation * frequency
        total_frequency += frequency

    mean = reference_value + sum_of_product_deviations / total_frequency

    return mean

data = [[10, 35], [15, 45], [18, 55], [27, 65], [35, 75], [19, 85], [6, 95]]
reference_value = 60  # You can change this to any reference value

mean_step_deviation = mean_grouped_data_step_deviation(data, reference_value)

print("The reference value for Step Deviation is", reference_value)
print("The mean calculated using the Step Deviation method is", mean_step_deviation)

"""2. Considering the data in Table 1, draw Ogive graphs (less-than Ogive and more-than Ogive) and
find the mean.
"""

import matplotlib.pyplot as plt

# Class intervals and frequencies
class_intervals = ["30-40", "40-50", "50-60", "60-70", "70-80", "80-90", "90-100"]
frequencies = [10, 15, 18, 27, 35, 19, 6]

# Calculate cumulative frequencies
cumulative_frequencies = []
cumulative_frequencies.append(frequencies[0])
for i in range(1, len(frequencies)):
    cumulative_frequencies.append(cumulative_frequencies[i - 1] + frequencies[i])

# Less than ogive
x = [i[0] for i in class_intervals]
y = cumulative_frequencies
plt.plot(x, y, label="Less than ogive")

# More than ogive
total_frequency = sum(frequencies)
y = [total_frequency - i for i in cumulative_frequencies]
plt.plot(x, y, label="More than ogive")

# Label the axes
plt.xlabel("Upper class limit")
plt.ylabel("Cumulative frequency")

# Show the legend
plt.legend()

# Display the graph
plt.show()

# Calculate mean
mid_values = [(int(cls.split('-')[0]) + int(cls.split('-')[1])) / 2 for cls in class_intervals]
mean = sum([freq * mid for freq, mid in zip(frequencies, mid_values)]) / total_frequency

print("Mean =", mean)

"""Write a program in R/Python to find median and mode of table 1 in Q1."""

from statistics import median, multimode

# Grouped data and frequencies
data_ranges = ["30-40", "40-50", "50-60", "60-70", "70-80", "80-90", "90-100"]
frequencies = [10, 15, 18, 27, 35, 19, 6]

# Calculate cumulative frequencies
cumulative_frequencies = [sum(frequencies[:i+1]) for i in range(len(frequencies))]

# Calculate the total number of data points
total_data_points = sum(frequencies)

# Calculate the median
midpoint = total_data_points / 2
median_class_index = None

for i, cf in enumerate(cumulative_frequencies):
    if cf >= midpoint:
        median_class_index = i
        break

lower_bound, upper_bound = map(int, data_ranges[median_class_index].split('-'))
median = lower_bound + ((midpoint - cumulative_frequencies[median_class_index - 1]) / frequencies[median_class_index]) * (upper_bound - lower_bound)

# Calculate the mode
mode_classes = [data_ranges[i] for i, freq in enumerate(frequencies) if freq == max(frequencies)]
modes = [int(cls.split('-')[0]) + (int(cls.split('-')[1]) - int(cls.split('-')[0])) / 2 for cls in mode_classes]

# Print the results
print("Median:", median)
print("Mode:", ", ".join(map(str, modes)))